# Bigger

This is a crystal native implementation of an arbitrary arithmetic math library. This library aims to provide
the same methods and interface that crystal's own `big` library provides.

## FAQ

**Is this faster than `big`?**

Nope.

**Is it more memory efficient?**

Still no.

**Is it written in Crystal?**

_Yes_.

**Can it be made more efficient?**

Absolutely. All operations were implemented using a naive algorithm. There's lots of room for improvement.

**Is it actually bigger?**

No. But it could be! Maybe! Being written in crystal means it can be modified as needed to support different use cases.

## Features

-[x] Big Int
-[ ] Big Float
-[ ] Big Decimal
-[ ] Big Rational

## Performance

Running with an intel i7-8565U 1.80GHz CPU. Benchmark run with numbers:

```crystal
a = 418376253051223933501534965978459129894917720729884038908657101374047974
b = 56628806604608093150302361055407918781958950380522727726457202444371318
```

|               | Big Operations | Bigger Operations | Big Avg Op Time | Bigger Avg Op Time | Bigger vs Big    |
| ------------- | -------------- | ----------------- | --------------- | ------------------ | ---------------- |
| a + b         | 33.04M         | 11.79M            | 30.27ns         | 84.84ns            | 2.80× slower     |
| a - b         | 29.95M         | 5.27M             | 33.39ns         | 189.74ns           | 5.68× slower     |
| a // b        | 8.17M          | 2.76k             | 122.42ns        | 361.68µs           | 7077.79× slower  |
| b // a        | 19.57M         | 8.75M             | 51.10ns         | 114.28ns           | 2.24× slower     |
| a % b         | 8.33M          | 2.97k             | 120.04ns        | 336.78µs           | 7127.89× slower  |
| b % a         | 21.16M         | 9.30M             | 47.25ns         | 107.47ns           | 2.27× slower     |
| a * b         | 20.85M         | 710.91k           | 47.96ns         | 1.41µs             | 29.33× slower    |
| a tdiv b      | 15.00M         | 1.35k             | 66.67ns         | 743.16µs           | 11147.29× slower |
| a remainder b | 8.64M          | 1.38k             | 115.76ns        | 726.52µs           | 6276.13× slower  |
| ~a            | 36.33M         | 5.72M             | 27.53ns         | 174.79ns           | 6.35× slower     |
| !a            | 551.25M        | 552.46M           | 1.81ns          | 1.81ns             | fastest          |
| a**(40)       | 351.06k        | 3.95k             | 2.85µs          | 252.97µs           | 88.81× slower    |
| a<<(40)       | 34.64M         | 5.64M             | 28.87ns         | 177.19ns           | 6.14× slower     |
| a>>(40)       | 31.42M         | 8.60M             | 31.83ns         | 116.27ns           | 3.65× slower     |

This table was generated by running `make benchmark`.

## Installation

1. Add the dependency to your `shard.yml`:

   ```yaml
   dependencies:
     bigger:
       github: vici37/bigger
   ```

2. Run `shards install`

## Usage

```crystal
require "bigger"

a = "418376253051223933501534965978459129894917720729884038908657101374047974".to_bigger_i
b = "56628806604608093150302361055407918781958950380522727726457202444371318".to_bigger_i

a + b
```


## Development

Specs are the lifeblood of any library's success. When making changes, make sure to run the specs
frequently. For convenience, you can use:

```
> make test
> make test-prod
```

The first one runs all of the specs using a base of `UInt8`, while the latter runs specs using with a base of `UInt32`.
Running with bases of `UInt8` tends to make things easier to debug as it's easier to test around the digit overflow points.

## Contributing

1. Fork it (<https://github.com/vici37/bigger-num/fork>)
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create a new Pull Request

## Contributors

- [Troy Sornson](https://github.com/vici37) - creator and maintainer
